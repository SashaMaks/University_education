## Максимов Александр ИТ-17-2024
### Вариант 9

# Лабораторная работа №6
## Задание 1
@Invoke
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически.

#### Решение:
Создадим аннотацию, с характеристиками:
- @Target(ElementType.METHOD) - цель это метод
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода

Далее создадим класс с методами, перед некоторыми мы напишем созданную аннотацию, перед одним не напишем:
- doTask() - открытый метод с аннотацией
- hiddenTask() - приватный метод с аннотацией
- regular() - открытый метод без аннотации

И создадим класс Processor, который будет обрабатывать все аннотации:
- напишем метод invokeAll, который смотрит, есть ли у каждого метода в классе аннотация, и если да игнорируя public/private он выполнит его
<img width="202" height="68" alt="image" src="https://github.com/user-attachments/assets/2a8dee5d-0414-44d7-8a56-2e7dfe854f0a" />

## Задание 2
@Default
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.


#### Решение:
Создадим аннотацию, с характеристиками:
- @Target({ElementType.TYPE,  ElementType.FIELD}) - цель это тип или поле
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода

Далее создадим класс с аннотацией @Default(String.class):
- в котором будет толоько поле значения String

В класс Processor добавим:
- метод проверяющий наличие у класса аннотации @Default, при ее наличии он выводит тип по умолчания, который указан в аннотации
<img width="296" height="66" alt="image" src="https://github.com/user-attachments/assets/d915ba1a-1f26-41ca-8325-ed2d2a45f043" />


## Задание 3
@ToString
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство value c двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES


#### Решение:
Создадим аннотацию, с характеристиками:
- @Target({ElementType.TYPE,  ElementType.FIELD}) - цель это тип или поле
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода
- Mode value() default Mode.YES; - свойство, значение которого по умолчанию YES

Далее создадим класс с аннотацией @ToString, в нем будет несколько полей:
- private String name = "Иван"; с аннотацией @ToString(Mode.YES)
- private String password = "secret"; с аннотацией @ToString(Mode.NO)
- private int age = 25; с аннотацией @ToString

В класс Processor добавим:
- метод который будет из класса брать все значения полей и если у них есть аннотация со значением YES иил если ее нет, то добавляет в вывод, который уже возвращается в main
<img width="704" height="46" alt="image" src="https://github.com/user-attachments/assets/33a32f68-ef91-4433-b123-1d03935e1bbb" />


## Задание 4
@Validate
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

#### Решение:
Создадим аннотацию, с характеристиками:
- @Target({ElementType.TYPE,  ElementType.ANNOTATION_TYPE}) - цель это тип или аннотация
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода
- Class<?>[] value(); - свойство, которое хранит массив значений

Далее создадим класс с аннотацией @Validate({NotNullValidator.class, PositiveValidator.class, EmailValidator.class}), в эту аннотацию мы помещаем методы для валидации/проверки:
- public class Class14, перед ним и находится аннотация
- class NotNullValidator
- class PositiveValidator
- class EmailValidator

В класс Processor добавим:
- метод который будет проверять есть ли аннотация у класса, есди да, то получаем значения записанные в аннотацию перед классом
<img width="811" height="136" alt="image" src="https://github.com/user-attachments/assets/7fb3ebcd-b254-45ca-8c08-135e15c491c2" />


## Задание 5
@Two
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

#### Решение:
Создадим аннотацию, с характеристиками:
- @Target(ElementType.TYPE) - цель это тип
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода
- String first(); - свойство, которое хранит строковое значение
- int second(); - свойство, которое хранит числовое значение

Далее создадим класс с аннотацией @Two(first = "Hello, World!", second = 42):
- public class Class15

В класс Processor добавим:
- метод который будет проверять есть ли аннотация у класса, есди да, то получаем и выводим значения записанные в аннотацию перед классом
<img width="512" height="94" alt="image" src="https://github.com/user-attachments/assets/c0185946-50da-4d73-94b5-ec17e111e066" />

## Задание 6
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.

#### Решение:
Создадим аннотацию, с характеристиками:
- @Target({ElementType.TYPE,  ElementType.FIELD}) - цель это тип или поле
- @Retention(RetentionPolicy.RUNTIME) - будет работать во время работы кода
- String[] value() default {}; - свойство, являяющееся массивом и хранящее по умолчанию пустой массив

Далее создадим несколько классов с аннотацией @Cache, в эту аннотацию мы записываем кешируемые области:
- class DataService - с аннотацией @Cache({"users", "products", "orders"})
- class SessionManager - с аннотацией @Cache("sessions")
- class DefaultCacheClassь - с аннотацией @Cache
- class NoCacheClass - без аннотаций

В класс Processor добавим:
- метод который проверяет наличие аннотации, затем если массив не пустой, то выводит список кешируемых областей записанных в аннотацию

Мы проверим сначала все по одному, а потом все одним списком этих же классов

<img width="375" height="552" alt="image" src="https://github.com/user-attachments/assets/64c4e1b2-6711-4fe6-b8fb-9f6d9f827ab1" />
